/*
 * generated by Xtext 2.27.0.M2
 */
package gendev.bot.turtle.generator

import gendev.bot.turtle.turtleLang.Move
import gendev.bot.turtle.turtleLang.Program
import gendev.bot.turtle.turtleLang.Repeat
import gendev.bot.turtle.turtleLang.Turn
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TurtleLangGenerator extends AbstractGenerator {

  override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
    val model = resource.contents.head as Program
    fsa.generateFile(resource.deriveArduinoFileNameFor, model.doGenerateArduinoCode)

  }

  def deriveArduinoFileNameFor(Resource resource) {
    resource.URI.lastSegment + "/" + resource.URI.appendFileExtension('ino').lastSegment
  }

  /**
   * generates code by pasting the fixed head and fixed tail of the program and 
   * then generating code for each statement
   * 
   */
  def String doGenerateArduinoCode(Program program) {
    head + '''
      «FOR stm : program.statement»
        «generateStatement(stm)»
      «ENDFOR»
    ''' + tail
  }

  dispatch def String generateStatement(Turn turn) '''
    «IF turn.dir=="left"»
      backA();
      forwardB();
    «ELSE»
      forwardA();
      backB();
    «ENDIF»
    delay(«5 * turn.degree»);
  '''

  dispatch def String generateStatement(Move move) '''
    «IF move.dir == "forward"»
      forwardA();
      forwardB();
    «ELSE»
      backA();
      backB();
    «ENDIF»
    delay(«500 * move.steps»);
  '''

  dispatch def String generateStatement(Repeat rep) '''
    for (int i = 0; i < «rep.times»; i++) {
      «FOR stm : rep.statements»
        «generateStatement(stm)»
      «ENDFOR»
    }
  '''
  
  val String head = '''
  #include <Arduino.h>
  
  #define MOTOR_A_PWM 26 //A-1A
  #define MOTOR_A_DIR 27 //A1-B
  #define MOTOR_B_PWM 33 //B-1A
  #define MOTOR_B_DIR 25 //B-1B
  // next one depends a lot on battery power
  #define PWM_SLOW 1023 //700  // slow speed PWM duty cycle
  
  
  int distance = 0;
  
  void setup() {

    pinMode( MOTOR_B_DIR, OUTPUT );
    pinMode( MOTOR_B_PWM, OUTPUT );
    digitalWrite( MOTOR_B_DIR, LOW );
    digitalWrite( MOTOR_B_PWM, LOW );
  
    pinMode( MOTOR_A_DIR, OUTPUT );
    pinMode( MOTOR_A_PWM, OUTPUT );
    digitalWrite( MOTOR_A_DIR, LOW );
    digitalWrite( MOTOR_A_PWM, LOW );
  }
  
  void loop() {
  '''
  
  val String tail = '''
    // stop and wait 5 sec before going again
    stopA();
    stopB();
    delay(5000);
  }
  
  void forwardA() {
    digitalWrite( MOTOR_A_DIR, HIGH ); // direction = forward
    analogWrite( MOTOR_A_PWM, 1023-PWM_SLOW ); // PWM speed = slow
  }
  void forwardB() {
    digitalWrite( MOTOR_B_DIR, HIGH ); // direction = forward
    analogWrite( MOTOR_B_PWM, 1023-PWM_SLOW ); // PWM speed = slow
  }
  
  void stopA() {
    digitalWrite( MOTOR_A_DIR, LOW ); // direction = forward
    digitalWrite( MOTOR_A_PWM, LOW ); // PWM speed = slow
  }
  void stopB() {
    digitalWrite( MOTOR_B_DIR, LOW ); // direction = forward
    digitalWrite( MOTOR_B_PWM, LOW ); // PWM speed = slow
  }
  
  void backA() {
    digitalWrite( MOTOR_A_DIR, LOW ); // direction = forward
    analogWrite( MOTOR_A_PWM, PWM_SLOW ); // PWM speed = slow
  }
  void backB() {
    digitalWrite( MOTOR_B_DIR, LOW ); // direction = forward
    analogWrite( MOTOR_B_PWM, PWM_SLOW ); // PWM speed = slow
  }
  '''
  
}
